---
title: ES2015读书笔记
date: 2016-02-23 01:12:12
tags:
---

## 变量的解构赋值
- “模式匹配”： 只要等号两边的模式相同，左边的变量久会被赋予相应的值；如果解构不成功，变量的值就等于`undefined`。 
- 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。


<!--more-->
### 默认值
- 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
	```js
		function f() {
  			console.log('aaa');
		}

		let [x = f()] = [1]; //因为x能取到值，所以函数f根本不会执行
	```

- 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。
- ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于`undefined`，默认值是不会生效的。 

### 对象的解构赋值
- 数组的元素是按次序排列的，变量的取值由它的位置决定，而对象的属性没有次序，变量必须与属性同名，才能取到正确的值
- 对象的解构赋值的内部机制，是：先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者(注:对象解构赋值只看分号后面的，如果有的话)
	```js
	let { foo: baz } = { foo: "aaa", bar: "bbb" };
	baz // "aaa"
	foo // error: foo is not defined
	//上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。
	```

- 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。


## 参考
[ECMAScript 6 入门](http://es6.ruanyifeng.com)